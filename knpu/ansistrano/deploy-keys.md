# Deploy Keys

Before we go further, we have a few very important things to talk about. First is kind of a neat one. Right now, we're always deploying the master branch of our site, and that probably makes sense. In theory, you might sometimes want to deploy a different branch, like maybe you're actually deploying to a beta server, and you want to deploy a branch that you're currently working on. If you want to do that, you can leverage something that is just native to Ansible, and that's vars_prompt. Here, we can basically ask the user which branch they want to deploy, and it will create a new variable called git_branch. We'll say prompt, "Enter a branch to deploy." We'll default to the master, and we'll save private no. Basically says it's not a secret thing, so it's okay to see the word that we type in at the command line instead of using stars. Then, down below, you do double quotes and say git_branch.

That's nothing amazing, but if it's useful for you, use it. The downside, it's now going to ask you a question at the beginning of every single deploy. For example, if we say ansible-playbook -i, ansible/hosts.ini, ansible/deploy.yml, when you hit Enter, it's going to ask you which branch you want to deploy to. I'll stop that so it doesn't go any further.

All right, the next thing we need to talk to you about is deploy keys. Right now, our deploy only really works because, well, my repository is public, so of course my server can access its files. I want you to change to use the SSH version of your repository, so get at as the protocol. Update your ansistrano_git_repo to use that. Then, try to redeploy.

This time, when it gets to the git part, it fails. Check this out. It says permission denied public key, could not read from remote repository. So in order to pull from a private git repository, normally the way this works is you upload your public key to your GitHub repository. Then, locally, whenever you try to clone something from a private repository, you have the private key locally, so it's able to pull that. Basically, to be able to talk to a private repository, you need to upload a public key to GitHub for authentication. Now, even for a public repository, this is failing right now, because our server doesn't have any public or private key associated with it. So even though this repository's public, it basically has the same problems, currently, as a private repository.

So I want to fix this properly, and the way to do it is with a deploy key. Here's how it works. First, locally, we're going to generate a new public/private key combination. I'm going to use ssh-keygen -the rsa -b 496 -c, then my email dress, ryan@knpuniversity.com, and then -for ansible/id_rsa. That's the path to the private key that this is about to generate. You can use a pass phrase if you want to. I won't. Then, the end result of this is that inside of our Ansible directory, we now have a new id_rsa private key and id_rsa.pub, the public key associated with that.

So the way deploy keys work is under the repository, you go to Settings, you go down to Deploy Keys, and you hit Add Deploy Key. I'll say something like aws ans is trying to deploy. Here, you're going to actually copy in your public IP address, your public key. I'll paste the public key in there and then hit Add Key. It'll ask for your password, and then there is the key. The nice thing is this is read only, so it will only give our server access to read this. This is only half of the battle, because we somehow need to tell ansistrano that when it clones from GitHub, it needs to use this private key right here as its identity key.

Fortunately, ansistrano has built-in support for this, and there's actually two ways to do it. Under the variables for git, you'll see two, ansistrano_git_identity_key_path and ansistrano_git_identity_key_remote_path. Basically, you need to have that private key somewhere. It can either be on your local machine, and you can use the first variable, and then ansistrano will use that key as your identity key when you talk with GitHub. Or you can put it on your remote server and then use this remote path. In that case, you might put the private key on your remote server once and then just point to the absolute path on the remote server where it is. If I were doing this, I would do it during the provisioning process. You could even store that private key on S3, and then during provisioning, you would download that from S3 somewhere onto your server.

I'm actually going to use the first one, ansistrano_git_identity_key_path. I'm going to set that as a new variable. You actually have two options here. I can just set this to the absolute path on my file system where that private key is, but then this playbook is only going to work for my local machine. Or you can use a variable called playbook_dir and actually point directly to the file that way. Playbook_dir is actually going to point to the Ansible directory, and then id_rsa is going to point to the private key. Now, when you do it this way, that file needs to live in that directory, so you either need to make sure that you do that and ignore the id_rsa from git or you need to do something very controversial, which is to commit that to your repository. What I mean is you could actually say git add ansible/id_rsa. I'll do everything else and do a commit, adding private deploy identity key to repo.

Now, obviously, that's a bit controversial, because I just committed a private key to my repository, which is not considered a best practice. It's also the easiest way to do this, because I didn't need to do any fancy setup, and anybody that has access to my repository automatically has access to my private key. Since that private key, the whole purpose of it is only to give you access, read-only access, to this repository, well, if they already were able to download your code, then they already have read-only access to it. Giving them access to the key doesn't really give them any extra access, but be aware of the implications of committing a private key to your repository.

Either way, as long as we have this variable set to a local path on my file system where the private key is, we should be able to deploy. So let's run our Ansible playbook one more time. This time, it works. Once it finishes, if you scroll up a little bit, it's actually pretty cool. You can see that it actually used the local Ensure GIT deployment key is up to date, so it used our local employment key and then later says shred GIT deployment key. It actually removes it from the server. The nice thing about using the local method is that the private key is not on your server after deployment finishes. It's just used during deployment. Now, whether you have a public or a private repository, you can actually deploy with it via the git repository method.

Next, we need to continue to get our site set up, run composer install, get database credential set up, all of the things that are specific to our application.

