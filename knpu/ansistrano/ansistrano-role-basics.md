# Ansistrano Role Basics

Our goal is to use Ansible to deploy our code to the server. Now, we already have an Ansible directory, which contains a bunch of files to support two playbooks. The first playbook, aws.yml, is able to create a new server on EC2. The second, playbook.yml, provisions that server, installing things like NGINX, PHP, and everything else we need. We’re now going to create a third playbook called “deploy.yml,” which will contain all the tasks we need to deploy our code.

Now, even though there are already a bunch of files and directories inside of the Ansible directory, this playbook is completely isolated. You don’t need to know anything about any of these other files or directories to understand how this deploy playbook will work. We will share a couple of things that I’ll show you, but I want you to know that this file is completely isolated.

To help us deploy with Ansible, of course, we’re going to use Ansistrano. You can check them out on ansistrano.com, which has some cool deployment details, and then I’m going to click the “ansible.deploy” to go to their GitHub. This is where all their documentation lives. Ansistrano very simply is a role, which basically means it’s a plug-in for Ansistrano … for Ansible.

The first we’re going to do is get it installed using ansible-galaxy. Now, instead of running this command, ansible-galaxy, to install the role, we’ve actually decided to manage our third-party roles with a requirements.yml file inside of our Ansible directory. This is just a nice way to say that we need the following Ansible roles.

Here, I’ll put another “src:” and I’ll grab just the first one, the ansistrano-deploy. We’ll talk about rollback later. Paste that there, and then for a version, you need to go and find the latest version of this library, so I’ll go up, click on “Releases,” and be careful because there are actually newer tags. Right now, it’s 2.7.0, so I’ll put 2.7.0.  You can use that same version, or if you want, if there’s a newer version, you can use the newer version. Then, to actually make sure that those are installed, we can run “ansible-galaxy install -r ansible /requirements.yml.” I already have the Redis role installed, and it downloaded the ansistrano-deploy to a user/local/etc directory. Perfect.

In our deploy.yml, we’ll start with the three dashes. Then, below that, I’m going to say which hosts this applies to, and I’m going to say AWS. Now, the only thing. If you’re using Ansistrano to deploy and you’re not using Ansible to provision your servers, the one thing you need to create in addition to the deploy.yml is the host.ini file, and it doesn’t need to be as complex as mine. You just need to have at least one host group with at least one IP address below it. In our case, we have a host group called “AWS.” Here’s our public IP address to that server, and then in our deploy.yml, I’m saying I’m going to deploy to any IP addresses under the AWS host group.

Below this, we’re going to say “roles:” and we are just going to copy the name of a role, so “roles: - carlosbuenosvinos.ansistrano-deploy.” If you went through our Ansible tutorial, you know that roles are basically just a bunch of tasks that are automatically brought into your playbook. Plus, a few other things like variables and handlers, but what’s cool is we have an empty playbook here except for this role.

We can get an idea of what that role contains by running “ansible-playbook -i ansible-hosts.ini.” That points ansible to our hosts file, and then to run … Now, we can point it to ansible/deploy.yml, and instead of executing that playbook, which we will do in a minute, right now, just pass “--list-tasks.” This will give us an idea of what this is going to do, and not all of this will make sense yet, but you can see things like “Ensure deployment base path exists.” Later, it’s creating something called a “current folder” and doing some cleanup at the end. We’ll learn about what all of this means.

In fact, if you go back to the Ansistrano homepage, and near the top, you’ll find a table of contents. I want you to click “Deploying.” This gives you an idea of how Ansistrano deploy works. It’s actually based on Capistrano, and what that means is it’s going to create a file structure automatically, which is going to be awesome. Every time we deploy, in this case, we’re deploying “var/www/my-app.com.” It’s going to put the new code inside of a releases director, which is a timestamp of that release.

Now, there’s going to be a current directory, which is going to be a symbolic link to the latest release. When you deploy again, it will create a new release directory, and it will update the symbolic link to point to the new release directory. This means our web server, NGINX, is actually going to be pointed at the current directory. There’s also a shared directory, which we’ll talk about later, which are files that can be shared between new releases. Now, you have files like database credential files that you want to share between every deployment.

In the very beginning, the only thing we really need to tell Ansistrano is what directory we want to deploy to. How do we tell it that? The way that you control third-party roles is through variables, and this is no different than Ansistrano. If you scroll up a little bit, you actually find a giant section. If you scroll up a little bit, you’ll find a giant box above this under role variables, and this tells you every single possible variable that you could override to control how Ansistrano works with documentation.

This is it right here. This tells you almost how to do everything, so let’s copy the “ansistrano_deploy_to” and then inside our playbook, we’ll create our own vars keyword, and we’ll set “ansistrano_deploy_to” and of course, we want to deploy to “var www project” so we’ll say, “/var/www/project.” Yeah. Let’s see what happens, right? I’ll go back to my terminal that’s running, my open terminal, run the same command, but without the “--list-tasks” flag.

You’ll notice some things talking about rsync. By default, Ansistrano uses “rsync” to actually rsync your files from your local machine up to your server. It’s not actually what we’re going to use, but it’s what it’s doing by default, and it finishes. Yeah. It looks successful, so go back to your tab where you’re logged in your server. If you “ls var www project” now, you see the structure we expected a second ago. We have a single release and a current directory is the symbolic link to that release, but if you look in current, there’s actually not much there.

There’s a revision file and then Ansible directory, and the Ansible directory actually is a mirror of the Ansible directory that we have in our project, so by default, what Ansistrano did was it actually deployed our Ansible directory because that’s the directory that our playbook lives in, so not exactly what we wanted. Next, we’re going to change our deployment strategy from “rsync” to “git” so that it actually clones down from our git repository and gets all of our files.
