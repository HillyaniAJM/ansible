# Ansible Modules

Ansible is full of things called modules. A module is a small program that executes over SSH. Most of the time, you won't think about, "I want to run this command." You'll be thinking about, "I want to execute this module and allow it to do whatever work it does." For example, there are modules that help you AptGet install on Ubuntu, and other modules that help you modify the contents of files on the server.
Of course when you run Ansible, you're always going to be running Ansible against another server or multiple other servers. Those are called the hosts. So we're always thinking about, "I want to run this module on those hosts." The simplest way to do all of this is from a command line, by using the Ansible command line to say 'ansible localhost,' which means for now, we're actually going to run this against our local host machine, '-m' for the module, and we're going to execute a module called command, which is the simplest module in Ansible.
We're going to pass the command module some arguments, which is /bin/echo Hello Ansible. We run it, we get back that response. The first module is command. In the second, I'll show you a giant list of all the built-in modules. You'll see how each module has its own arguments that you can pass to them. In fact, the command module is so fundamentally important, it is actually the default module, so if we don't pass -m, it defaults to the command module.
Another example is ansible localhost -m ping. The ping module, which, as you probably guessed, is a small program that makes sure that we can ping the server, or more specifically, make sure that we can SSH onto that server, or connect to that server, however we're set up to do that.
Okay, cool. So what other modules do we have? Flip back to your browser and Google for Ansible modules. They have a couple of cool pages on this, like modules by category. I'm going to go to the list of all modules. This should get you really excited. These are built-in programs so that you don't have to do a lot of work to get a lot of work done.
One of them which is familiar to us is called Composer, the same module that is really good at working with Composer. For example, back on the command line, right now the vendor directory is populated with all of my vendor files, but let's delete vendor. Let's rm -rf it. Let's see if we can use the Composer module to re-populate that. So ansible localhost -m composer.
Aah. You can see it actually fails. Missing required arguments: working_dir. So whenever you look at a specific module page, it's awesome because it's going to give you all of the options, their default value, and whether or not they are required like working_dir. Below, they usually have a bunch of really good examples. In this case, we need to pass -a working:dir= In this case we can just pass it ./, because we're working right on our local machine. I also want you to pass no_dev=false. This is another option from the Composer module, and we're going to talk more about why that's necessary in a little bit.
This time, it's actually working. In fact, you can see in the tab behind the scenes, it was running some items. Boom! Check this out. We see the full output of all of that stuff happening. I want you to notice that it says changed true, and the output comes back as yellow. The module is actually detecting that this command did something. It made a change to the server. If you try it again right now, it comes back as green, and it says changed false.
That is one of the important superpowers of modules. Not only do they make something happen on your server, do they get your server into a specific state - in this case, they make sure that our Composer is installed - it's able to detect whether or not it made a change on when it ran that, which is going to become important later when we start triggering different actions based on whether or not something.
How does this work? It's actually built into the module itself. The Composer module is smart enough to know that nothing changed based on the output of the command. By the way, knowing what we know now, we could have actually cleared the vendor directory by using the command module, which is the default module, and passing that, rm -rf vendor. Just to prove that that worked, we'll run the Composer one again, and this time we're going to come back and we're going to get that yellow changed state once again.
That's just touching the surface of modules. Next, let's talk about how we organize what actual servers that these run on, because obviously we're not going to be running these on our local server forever.

