# EC2 Deploy Group VARS

So far we've been deploying everything to our virtual machine but there's nothing stopping us from using Virtual Box to deploy somewhere else like to Amazon EC2, to a real server. Real quick, I'm going to try that. This isn't going be an exhaustive tutorial about using EC2 but I want to get our feet wet at least.

I'm already in my EC2 dashboard. I'm going to hit "Launch Instance." Down to Quick Start, what I'm looking for here is an image that's at least similar to the image we're using which is Ubuntu 14.04. I'm going to select that AMI and I use the Micro server and most of the settings are going to be just fine for us. For the security group, I'm going to select an existing group I've created before which is called "Web Access Testing." The important thing is you can see it allows port 22 so we can SSH and port 80 and port 443. Then, I'll hit review and launch and finally, launch.

The other thing you need to choose is a key pair to log into the server. I already created a key pair for this tutorial called "Ansible AWS_tmp." The important thing here is, when we launch the instance, instead of logging in with a username and password, we're going to log into the username and a private key. When you create a new key pair on Amazon, you download that private key. In this case, it would be called "Ansible AWS_tmp.pem." I've already downloaded that file. With that, instance launch. Then, we'll click to view its progress.

While it's loading, this represents a new host. On our host.ini file, right now we have localhost, we have virtual box, now we have another one called "AWS." What we're going to use here is the IP address from the server. Wait for it to boot. As soon as it's booted, you can grab its public IP address down here and we use that. We are now writing "ansible_user" to set the SSH user. On these AMI's is called "Ubuntu" and then, instead of an SSH pass, we're going to pass "ansible_ssh_private_key_file=" and then, the path to where we downloaded that private key file. In my case, I downloaded into my home directory .ssh/ansible_aws_temp.pem. If you downloaded your private key to another spot, just update that accordingly.

Now, here's the cool thing. I actually want to run our playbook against both hosts. There's nothing stopping us from executing Ansible and having to build our dev server and having to build another server on Amazon at the same time. Right now, we have each of these under two different host groups, a group called "VB" and a group called "AWS." Instead of our playbook right now, we're saying to run VB so we can change that to AWS to deploy to that one server or we can create a new host group inside the host.ini that contains both. To do that, you'll say "web server," that's the name of the new host group we're creating and calling "children," that special calling "children" syntax allows you now below just to say "VB" and "AWS." What that does is create a new host group called "web server" that contains the VB group and the AWS group. In this case, it will contain two hosts but if the AWS group had five hosts under it, then this would now contain six hosts, the five from AWS and the one from VB. Now in our playbook, we can change this to just "web server."

All right, moment of truth. Run our playbook, ansible-playbook, ansible/playbook.yml -i ansible/hosts.ini --ask-vault-pass. We're filling V pass and then, we will watch the magic happen. You'll probably need to verify the authenticity of your host. By the way, there is an Ansible module that can help you with that. Then, you'll start to see it execute each task against both of our servers. The first time we do this, it's going to take a while because that brand new server on Amazon needs to have things set up.

While we're waiting, I'm going to go copy the IP address to our new server, 52.14.198.114, then I'm going to create a new terminal tab just so I can temporarily open my /etc/hosts file and down here, I'm going to stop pointing mootube.l to our virtual machine. Instead, we'll replace it with the IP address to our Amazon machine. We got a new mootube.l, it should now hit our virtual machine. I'll save that and I'll close this tab.

Now, since our task is still running, if I got to mootube.l, I just get "Welcome to nginx" and if you do this fast enough, you won't even get that. That showed up because nginx is already installed but there's not much else happening quite yet and nginx hasn't even been restarted. Let's wait for this to finish.

Beautiful. All right. Moment of truth. We're going to flip back over, refresh and boom, welcome to MooTube up on our brand new Amazon EC2 machine. We notice there's no data because we loaded it in the prod environment so it didn't load fixtures but this is beautiful.

Now, I want to show you one more interesting thing about these host groups. The problem now is mootube.l goes to my Amazon machine, no longer goes to my virtual machine. It might be kind of nice if mootube.l for local went to my virtual box machine but maybe something else like mootube.ec2 went to my EC2 machine.

The problem, of course, is that in our roles, nginx, vars, main.yml file, we're setting the server name right here and this is ultimately what's used inside of our nginx sites to set what site is being responded to. What we effectively want to do is have a different server name variable for the different host groups and this is actually totally possible.

First, I want to go in and open up my etc/hosts file and we're going to put it back so that mootube.l goes to virtual machine but the Amazon, where we have mootube.ec2 that goes to our EC2 instance. Perfect. Next, because our Amazon machine is under an AWS group, that allows us to set variables specific to that group alone. The way you do that is inside of your Ansible directory, create a new directory called "group_vars" with one called "aws.yml." By having a group_vars directory, aws.yml file, whenever the aws group is executed, it's automatically going to load this file and set those variables for only that group. It means inside of here, we can say something like "host_server_name" and we'll say "mootube.ec2." We'll set a new variable called "host server name."

I'll copy that because now inside of our roles, nginx roles, main.yml, instead of putting "mootube.l" here, we can do something a little fancier. We can use [inaudible 00:12:06] to print out "host server name" but then pipe it to default and say "mootube.l." In other words, use a host server name variable if one exists, otherwise just print out mootube.l. we should be able to get two different host names on these two different groups.

All right. Let's go back, run our playbook and try that guy out. You can see a few changes here on the EC2 server only, laid it to nginx sites available because now it should be using that new host name. Beautiful. Go back to your server. If you refresh mootube.l, now this is loading from our virtual machine. You can tell because we have data there. What if we change this to "mootube.ec2?" That hits our EC2 machine. In just a couple of minutes, we just deployed the EC2.

